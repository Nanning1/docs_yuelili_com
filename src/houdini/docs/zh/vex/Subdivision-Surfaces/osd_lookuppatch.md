---
title: osd_lookuppatch
order: 7
category:
  - vex
---

`int osd\_lookuppatch(<geometry>geometry, int face\_id, float face\_u, float face\_v, int &patch\_id, float &patch\_u, float &patch\_v)`

If you don’t specify a texture attribute, the function uses intrinsic polygon interpolants.

`int osd\_lookuppatch(<geometry>geometry, int face\_id, float face\_u, float face\_v, int &patch\_id, float &patch\_u, float &patch\_v, string attribute)`

If you specify a texture attribute, the function uses the UVs in that attribute to translate the face coordinates onto the OSD patch.

Given the `face_id` and texture coordinates for a point inside the face (`face_u` and`face_v`), this function will return the corresponding `patch_id` (Catmull-Clark subdivision face) and the patch interpolants (`patch_u` and `patch_v`). The reverse function to map from patch to face is [osd_lookupface](osd_lookupface.html "Outputs the Houdini face and UV coordinates corresponding to the given coordinates on an OSD patch.").

## Arguments

`<geometry>`

When running in the context of a node (such as a wrangle SOP), this argument can be an integer representing the input number (starting at 0) to read the geometry from.

Alternatively, the argument can be a string specifying a geometry file (for example, a `.bgeo`) to read from. When running inside Houdini, this can be an `op:/path/to/sop` reference.

`face_id`

The primitive number of the Houdini polygon face.

`face_u`, `face_v`

The coordinates in the subdivision patch to map onto a Houdini primitive.
These should have values in the range 0 to 1. Not all values are valid for triangles.
The texture coordinates should be specified according to the attribute passed in.
If you pass invalid coordinates, the function will fail and return `0`.

`&patch_id`

The function overwrites this variable with the corresponding OSD patch number.
This is also the same integer value used to identify the face when performing PTex texture mapping.

`&patch_u`, `&patch_v`

The function overwrites these variables with the corresponding U/V coordinates on the OSD patch.

## Returns

`1` on success or `0` on an error.

## Examples

[¶](#examples)

```c
// This function can be used to move points generated by a scatter SOP to the
// subdivision limit surface. The scatter SOP needs to store the "sourceprim"
// (the Output Attributes tab). Texture coordinates also need to be
// transferred from the source geometry.
void
movePointToLimitSurface(string file; vector P, uv; int sourceprim)
{
 int patch\_id = -1;
 float patch\_u, patch\_v;
 if (osd\_lookuppatch(file, sourceprim, uv.x, uv.y,
 patch\_id, patch\_u, patch\_v, "uv"))
 {
 vector tmpP;
 if (osd\_limitsurface(file, "P", patch\_id, patch\_u, patch\_v, tmpP))
 P = tmpP;
 }
}

```



## See also

- [osd_lookupface](osd_lookupface.html)
- [osd_patchcount](osd_patchcount.html)
- [osd_facecount](osd_facecount.html)
- [osd_firstpatch](osd_firstpatch.html)
- [osd_limitsurface](osd_limitsurface.html)

|
subd

[osd_facecount](osd_facecount.html)

[osd_firstpatch](osd_firstpatch.html)

[osd_limitsurface](osd_limitsurface.html)

[osd_limitsurfacevertex](osd_limitsurfacevertex.html)

[osd_lookupface](osd_lookupface.html)

[osd_lookuppatch](osd_lookuppatch.html)

[osd_patchcount](osd_patchcount.html)

[osd_patches](osd_patches.html)
